<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta property="wb:webmaster" content="65a151beb5e21880" />
	<!-- baidu analytics-->
	<script>
		var _hmt = _hmt || [];
		(function() {
			var hm = document.createElement("script");
			hm.src = "https://hm.baidu.com/hm.js?09df6a0c610161ab3099d8e11e9c998e";
			var s = document.getElementsByTagName("script")[0];
			s.parentNode.insertBefore(hm, s);
		})();
	</script>
	<!-- google analytics-->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
		ga('create', 'UA-86667923-1', 'auto');
		ga('send', 'pageview');
	</script>
	
	<title>Javascript 设计缺陷 | Bevis Blog - 沈浩个人博客</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="description" content="随着 ES6 的普及，加上 babel 这种工具的使用，慢慢越多越多的前端开发或者 node 开发使用 ES6 来建立项目，之所以能走到 ES6 也是因为一开始创造 JS 的 Brendan Eich 这这哥们花了十来天时间创造了这语言（没看错，发明 js 就花了10天）一开始只是为了在浏览器端执行，当时的浏览器功能又非常的 low，导致一开始的 js 语言也同样比较简陋，虽然到 ES3 和 ES">
<meta name="keywords" content="Javascript">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript 设计缺陷">
<meta property="og:url" content="https://utopia1991.github.io/2017/06/08/jsBug/index.html">
<meta property="og:site_name" content="Bevis Blog - 沈浩个人博客">
<meta property="og:description" content="随着 ES6 的普及，加上 babel 这种工具的使用，慢慢越多越多的前端开发或者 node 开发使用 ES6 来建立项目，之所以能走到 ES6 也是因为一开始创造 JS 的 Brendan Eich 这这哥们花了十来天时间创造了这语言（没看错，发明 js 就花了10天）一开始只是为了在浏览器端执行，当时的浏览器功能又非常的 low，导致一开始的 js 语言也同样比较简陋，虽然到 ES3 和 ES">
<meta property="og:image" content="https://utopia1991.github.io/images/jsBug/1.jpg">
<meta property="og:updated_time" content="2017-06-08T06:53:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Javascript 设计缺陷">
<meta name="twitter:description" content="随着 ES6 的普及，加上 babel 这种工具的使用，慢慢越多越多的前端开发或者 node 开发使用 ES6 来建立项目，之所以能走到 ES6 也是因为一开始创造 JS 的 Brendan Eich 这这哥们花了十来天时间创造了这语言（没看错，发明 js 就花了10天）一开始只是为了在浏览器端执行，当时的浏览器功能又非常的 low，导致一开始的 js 语言也同样比较简陋，虽然到 ES3 和 ES">
<meta name="twitter:image" content="https://utopia1991.github.io/images/jsBug/1.jpg">
	
	
		<link rel="icon" href="https://utopia1991.github.io/css/images/icon.png">
	
	
		<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
	
	<link rel="stylesheet" href="/css/style.css">
	

	<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
</head>

<body>
	<a href="https://github.com/utopia1991" target="_blank" class="githubFork">
		<img src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png">
	</a>
	<a class="backTop" onclick="backTop()">Top</a>
	<div id="container">
		<div id="wrap">
			<header id="header">
	<div id="header-outer" class="outer">
		<div id="header-title" class="inner">
			<h1 id="logo-wrap">
				<a href="/" id="logo">
					<span class="brand-logo">Bevis</span>
					Blog
				</a>
			</h1>
		</div>
		<div id="header-inner" class="inner">
			<nav id="main-nav">
				<a id="main-nav-toggle" class="nav-icon"></a>
				
					<a class="main-nav-link" href="/">主页</a>
				
					<a class="main-nav-link" href="/archives">博文</a>
				
				<a class="main-nav-link" href="https://utopia1991.github.io/p/about/index.html">关于我</a>
			</nav>
		</div>
	</div>
</header>

			<canvas width="100%" height="100%" id="canvas"></canvas>
			<div class="outer">
				
				<aside id="sidebar">
	<div class="aside-author">
		<a class="aside-logo" href="https://utopia1991.github.io/p/lover/index.html" target="_blank"></a>
		<p class="aside-title">Bevis Shen（沈浩）</p>
		<p class="aside-subtitle">Node.js & Front-End Engineer</p>
		<p class="aside-description">Google 重度粉，Mac 拥趸，前端 + Node 青年，对前沿技术有着狂热的激情，梦想环游世界，热爱生活、摄影、旅游、电影的文艺程序猿一枚</p>
		<div class="aside-communicate">
			<a href="https://github.com/utopia1991" target="_blank" class="article-share-github" title="github"></a>
			<a href="https://www.linkedin.com/in/bevis1991" target="_blank" class="article-share-linkedin" title="linkedin"></a>
			<a href="mailto:1304354608@qq.com" class="article-share-mail" title="email"></a>
			<a href="https://weibo.com/u/2619492527/home" target="_blank" class="article-share-weibo" title="weibo"></a>
			<a class="article-share-weixin" title="我的个人微信公众号"></a>
			<img src="https://utopia1991.github.io/css/images/wechat.png" width="180" height="180" class="wechat-pic">
			<a href="https://bevis1991.wordpress.com/" target="_blank" class="article-share-wordpress" title="WordPress 博客"></a>
			<a href="https://www.facebook.com/bevis1991" target="_blank" class="article-share-facebook" title="facebook"></a>
			<a href="https://twitter.com/bevis_shen" target="_blank" class="article-share-twitter" title="twitter"></a>
		</div>
	</div>
	
		

	
		
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/">CSS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Code-Style/">Code Style</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coffeescript/">Coffeescript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Google/">Google</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gulp/">Gulp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/">HTTP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interview-Questions/">Interview-Questions</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript/">Javascript</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac/">Mac</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UnderscoreJS/">UnderscoreJS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodeJs/">nodeJs</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


	
		
  <div class="widget-wrap">
    <h3 class="widget-title">Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/Code-Style/" style="font-size: 16.67px;">Code Style</a> <a href="/tags/Coffeescript/" style="font-size: 10px;">Coffeescript</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/Gulp/" style="font-size: 10px;">Gulp</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Interview-Questions/" style="font-size: 16.67px;">Interview-Questions</a> <a href="/tags/Javascript/" style="font-size: 20px;">Javascript</a> <a href="/tags/Mac/" style="font-size: 13.33px;">Mac</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 13.33px;">MongoDB</a> <a href="/tags/UnderscoreJS/" style="font-size: 13.33px;">UnderscoreJS</a> <a href="/tags/jQuery/" style="font-size: 13.33px;">jQuery</a> <a href="/tags/nodeJs/" style="font-size: 10px;">nodeJs</a>
    </div>
  </div>

	
		
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">42</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


	
		
	<div class="widget-wrap">
		<h3 class="widget-title">最新文章</h3>
		<div class="widget">
			<ul>
				
					<li>
						<a href="/2017/06/08/dom/">
							Javascript DOM
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/event/">
							Javascript 事件处理
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/bom/">
							Javascript BOM
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/baseInterviews/">
							web 前端常见面试题
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/codeStyle1/">
							前端编码规范 1 —— 一般规范
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/bem/">
							BEM - CSS 命名规则
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/codeStyle3/">
							前端编码规范 3 —— JavaScript 规范
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/codeStyle2/">
							前端编码规范 2 —— HTML 规范
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/codeStyle4/">
							前端编码规范 4 —— CSS 和 SASS 规范
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/coffee/">
							Coffeescript 学习笔记
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/commandLine/">
							Mac 常用终端命令
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/eslint/">
							EsLint入门
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/deferred/">
							jQuery $.deferred()对象
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/dust/">
							Dust 模版引擎
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/eventLoop/">
							JavaScript 运行机制
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/express/">
							Node.js Express 框架
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/fisher/">
							Fisher–Yates shuffle 洗牌算法
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/google/">
							教你使用 Google
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/getPost/">
							Get 与 Post 区别
						</a>
					</li>
					
					<li>
						<a href="/2017/06/08/inherit/">
							Javascript 继承：经典继承，ES5 继承，ES6 继承
						</a>
					</li>
					
				......
			</ul>
		</div>
	</div>
	

	
</aside>

				
				<section id="main">
					<div class="main-header">
						<p class="header-title">Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>
						<canvas id="bubbleCanvas" width="100%" height="300" style="margin-top:50px;"></canvas>
						<script>
							(function(){
								var width, height, canvas, ctx, circles;
								function initHeader() {
									try{
										canvas = document.getElementById('bubbleCanvas');
										if($("#bubbleCanvas").length>0){
											width = window.innerWidth*0.25>300?window.innerWidth*0.25:300;
											//height = window.innerHeight;
											height = 255;
											canvas.width = width;
											canvas.height = height;
											ctx = canvas.getContext('2d');
											circles = [];
											for(var x = 0; x < width*0.5; x++) {
												var c = new Circle();
												circles.push(c);
											}
											animate();
										}
									} catch(ex) {
										if(window.cosole&&window.cosole.log){cosole.log(ex)}
									}
								}
								function addListeners() {
									try{
										if($("#bubbleCanvas").length>0){
											window.addEventListener('resize', resize);
										}
									}catch(ex){if(window.cosole&&window.cosole.log){cosole.log(ex)}}
								}
								function resize() {
									width = window.innerWidth*0.25>300?window.innerWidth*0.25:300;
									height = window.innerHeight;
									canvas.width = width;
									canvas.height = height;
								}
								function animate() {
									ctx.clearRect(0,0,width,height);
									for(var i in circles) {
										circles[i].draw();
									}
									window.requestAFrame = (function () {
										return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||
											function (callback) {
												return window.setTimeout(callback, 1000 / 60); // shoot for 60 fps
											};
									})();
									requestAFrame(animate);
								}
								// Canvas manipulation
								function Circle() {
									var _this = this;
									// constructor
									(function() {
										_this.pos = {};
										init();
									})();

									function init() {
										_this.pos.x = Math.random()*width;
										_this.pos.y = height+Math.random()*100;
										_this.alpha = 0.1+Math.random()*0.3;
										_this.scale = 0.1+Math.random()*0.3;
										_this.velocity = Math.random();
									}

									this.draw = function() {
										if(_this.alpha <= 0) {
											init();
										}
										_this.pos.y -= _this.velocity;
										_this.alpha -= 0.0005;
										ctx.beginPath();
										ctx.arc(_this.pos.x, _this.pos.y, _this.scale*10, 0, 2 * Math.PI, false);
										ctx.fillStyle = 'rgba(255,255,255,'+ _this.alpha+')';
										ctx.fill();
									};
								}
								initHeader();
								addListeners();
							}());
						</script>
					</div>
					<article id="post-jsBug" class="article article-type-post" itemscope itemprop="blogPost">
	<div class="article-meta">
		
	</div>
	<div class="article-inner">
		
		
			<header class="article-header">
				
	
		<h1 class="article-title" itemprop="name">
			Javascript 设计缺陷
		</h1>
	


				<a href="/2017/06/08/jsBug/" class="article-date">
  <time datetime="2017-06-08T06:53:50.000Z" itemprop="datePublished">2017-06-08</time>
</a>
			</header>
		
		<div class="article-entry" itemprop="articleBody">
			
				<p>随着 ES6 的普及，加上 babel 这种工具的使用，慢慢越多越多的前端开发或者 node 开发使用 ES6 来建立项目，之所以能走到 ES6 也是因为一开始创造 JS 的 Brendan Eich 这这哥们花了十来天时间创造了这语言（没看错，发明 js 就花了10天）一开始只是为了在浏览器端执行，当时的浏览器功能又非常的 low，导致一开始的 js 语言也同样比较简陋，虽然到 ES3 和 ES4 的改进依然存在一些问题，直到 ES6 诞生，js 之前的好多 bug 被修复，那我们来看看我总结的一些对于 js 的设计缺陷（这些还是比较浅显的，还有深层次的，还在研究中）。</p><p><img src="/images/jsBug/1.jpg" alt=""></p><a id="more"></a><h4 id="1-相等运算符"><a href="#1-相等运算符" class="headerlink" title="1.相等运算符 =="></a>1.相等运算符 ==</h4><p>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；</p><p>第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p><p>由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。</p><h4 id="2-strict-模式"><a href="#2-strict-模式" class="headerlink" title="2.strict 模式"></a>2.strict 模式</h4><p>JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></div></pre></td></tr></table></figure><p>在同一个页面的不同的JavaScript文件中，如果都不用var申明，恰好都使用了变量i，将造成变量i互相影响，产生难以调试的错误结果。</p><p>使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。</p><p>为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。</p><p>启用strict模式的方法是在JavaScript代码的第一行写上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div></pre></td></tr></table></figure><p>这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。</p><h4 id="3-hasOwnProperty-和-in"><a href="#3-hasOwnProperty-和-in" class="headerlink" title="3.hasOwnProperty() 和 in"></a>3.hasOwnProperty() 和 in</h4><p>如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">  <span class="attr">school</span>: <span class="string">'No.1 Middle School'</span>,</div><div class="line">  <span class="attr">height</span>: <span class="number">1.70</span>,</div><div class="line">  <span class="attr">weight</span>: <span class="number">65</span>,</div><div class="line">  <span class="attr">score</span>: <span class="literal">null</span></div><div class="line">&#125;;</div><div class="line"><span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div><div class="line"><span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></div></pre></td></tr></table></figure><p>不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。</p><p>要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span></div><div class="line">&#125;;</div><div class="line">xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></div><div class="line">xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure><h4 id="4-if…else…语句"><a href="#4-if…else…语句" class="headerlink" title="4.if…else…语句"></a>4.if…else…语句</h4><p>if…else…语句的执行特点是二选一，在多个if…else…语句中，如果某个条件成立，则后续就不再继续判断了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line"><span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</div><div class="line">  alert(<span class="string">'teenager'</span>);</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</div><div class="line">  alert(<span class="string">'adult'</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  alert(<span class="string">'kid'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于age的值为20，它实际上同时满足条件age &gt;= 6和age &gt;= 18，这说明条件判断的顺序非常重要。</p><p>如果if的条件判断语句结果不是true或false怎么办？例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'123'</span>;</div><div class="line"><span class="keyword">if</span> (s.length) &#123; <span class="comment">// 条件计算结果为3</span></div><div class="line">  <span class="comment">//</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JavaScript把null、undefined、0、NaN和空字符串’’视为false，其他值一概视为true，因此上述代码条件判断的结果是true。</p><h4 id="5-小心-return"><a href="#5-小心-return" class="headerlink" title="5.小心 return"></a>5.小心 return</h4><p>前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'foo'</span> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// &#123; name: 'foo' &#125;</span></div></pre></td></tr></table></figure><p>如果把return语句拆成两行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'foo'</span> &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure><p>由于JavaScript引擎在行末自动添加分号的机制，上面的代码实际上变成了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span>; <span class="comment">// 自动添加了分号，相当于return undefined;</span></div><div class="line">    &#123; <span class="attr">name</span>: <span class="string">'foo'</span> &#125;; <span class="comment">// 这行语句已经没法执行到了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所以正确的多行写法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></div><div class="line">    name: <span class="string">'foo'</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="6-变量提升"><a href="#6-变量提升" class="headerlink" title="6.变量提升"></a>6.变量提升</h4><p>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">  alert(x);</div><div class="line">  <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();</div></pre></td></tr></table></figure><p>虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。</p><p>对于上述foo()函数，JavaScript引擎看到的代码相当于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y; <span class="comment">// 提升变量y的申明</span></div><div class="line">  <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">  alert(x);</div><div class="line">  y = <span class="string">'Bob'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span></div><div class="line">    x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></div><div class="line">    y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></div><div class="line">    z, i; <span class="comment">// z和i为undefined</span></div><div class="line">  <span class="comment">// 其他语句:</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="7-全局作用域"><a href="#7-全局作用域" class="headerlink" title="7.全局作用域"></a>7.全局作用域</h4><p>不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</div><div class="line">alert(course); <span class="comment">// 'Learn JavaScript'</span></div><div class="line">alert(<span class="built_in">window</span>.course); <span class="comment">// 'Learn JavaScript'</span></div></pre></td></tr></table></figure><p>因此，直接访问全局变量course和访问window.course是完全一样的。</p><p>你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">'foo'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(); <span class="comment">// 直接调用foo()</span></div><div class="line"><span class="built_in">window</span>.foo(); <span class="comment">// 通过window.foo()调用</span></div></pre></td></tr></table></figure><p>进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量。</p><p>这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</p><h4 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h4><p>在一个对象中绑定函数，称为这个对象的方法。</p><p>在JavaScript中，对象的定义是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>但是，如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">  <span class="attr">age</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age; <span class="comment">// function xiaoming.age()</span></div><div class="line">xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure><p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个东东是什么？</p><p>在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。</p><p>让我们拆开写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">  <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">  <span class="attr">age</span>: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25, 正常结果</span></div><div class="line">getAge(); <span class="comment">// NaN</span></div></pre></td></tr></table></figure><p>单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。</p><p>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？</p><p>答案是，视情况而定！</p><p>如果以对象的方法形式调用，比如xiaoming.age()，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。</p><p>如果单独调用函数，比如getAge()，此时，该函数的this指向全局对象，也就是window。</p><p>坑爹啊！</p><p>更坑爹的是，如果这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></div><div class="line">fn(); <span class="comment">// NaN</span></div></pre></td></tr></table></figure><p>也是不行的！要保证this指向正确，必须用obj.xxx()的形式调用！</p><p>由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">    <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">    <span class="attr">age</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">        <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> fn = xiaoming.age;</div><div class="line">fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure><p>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。</p><p>有些时候，喜欢重构的你把方法重构了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">  <span class="attr">age</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">      <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>xiaoming.age(); // Uncaught TypeError: Cannot read property ‘birth’ of undefined<br>结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）</p><p>修复的办法也不是没有，我们用一个that变量首先捕获this：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">  <span class="attr">age</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">      <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div></pre></td></tr></table></figure><p>用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p><h4 id="9-apply-方法"><a href="#9-apply-方法" class="headerlink" title="9.apply 方法"></a>9.apply 方法</h4><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p><p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p><p>用apply修复getAge()调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">  <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'小明'</span>,</div><div class="line">  <span class="attr">birth</span>: <span class="number">1990</span>,</div><div class="line">  <span class="attr">age</span>: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div><div class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure><p>另一个与apply()类似的方法是call()，唯一区别是：</p><ul><li><p>apply()把参数打包成Array再传入；</p></li><li><p>call()把参数按顺序传入。</p></li></ul><p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure><p>对普通函数调用，我们通常把this绑定为null。</p><p>使用 filter方法去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> r,</div><div class="line">  arr = [‘apple’, ’strawberry’, ’banana’, ‘pear’, ‘apple’, ‘orange’, ‘orange’, ’strawberry’];</div><div class="line"></div><div class="line">r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, self</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> self.indexOf(element)  ===  index;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="10-Array-的-sort-方法"><a href="#10-Array-的-sort-方法" class="headerlink" title="10.Array 的 sort() 方法"></a>10.Array 的 sort() 方法</h4><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。<br>JavaScript的Array的sort()方法就是用于排序的，但是排序结果可能让你大吃一惊：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 看上去正常的结果:</span></div><div class="line">[<span class="string">'Google'</span>, <span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>].sort(); <span class="comment">// ['Apple', 'Google', 'Microsoft'];</span></div><div class="line"></div><div class="line"><span class="comment">// apple排在了最后:</span></div><div class="line">[<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>].sort(); <span class="comment">// ['Google', 'Microsoft", 'apple']</span></div><div class="line"></div><div class="line"><span class="comment">// 无法理解的结果:</span></div><div class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></div></pre></td></tr></table></figure><p>第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。</p><p>第三个排序结果是什么鬼？简单的数字排序都能错？</p><p>这是因为Array的sort()方法默认把所有元素先转换为String再排序，结果’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。</p><p>如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！</p><p>幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。</p><p>要按数字大小排序，我们可以这么写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (x &lt; y) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;); <span class="comment">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x-y;</div><div class="line">&#125;); <span class="comment">// [1, 2, 10, 20]</span></div><div class="line">如果要倒序排序，我们可以把大的数放前面：</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (x &lt; y) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;); <span class="comment">// [20, 10, 2, 1]</span></div></pre></td></tr></table></figure><p>可以简写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> y-x;</div><div class="line">&#125;); <span class="comment">// [20, 10, 2, 1]</span></div></pre></td></tr></table></figure><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</div><div class="line">  x1 = s1.toUpperCase();</div><div class="line">  x2 = s2.toUpperCase();</div><div class="line">  <span class="keyword">if</span> (x1 &lt; x2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (x1 &gt; x2) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;); <span class="comment">// ['apple', 'Google', 'Microsoft’]</span></div></pre></td></tr></table></figure><p>忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p><p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p><p>最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a1 = [<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>];</div><div class="line"><span class="keyword">var</span> a2 = a1.sort();</div><div class="line">a1; <span class="comment">// ['A', 'B', 'C']</span></div><div class="line">a2; <span class="comment">// ['A', 'B', 'C']</span></div><div class="line">a1 === a2; <span class="comment">// true, a1和a2是同一对象</span></div></pre></td></tr></table></figure><h4 id="11-包装对象"><a href="#11-包装对象" class="headerlink" title="11.包装对象"></a>11.包装对象</h4><p>除了这些类型外，JavaScript还提供了包装对象，熟悉Java的小伙伴肯定很清楚int和Integer这种暧昧关系。<br>number、boolean和string都有包装对象。没错，在JavaScript中，字符串也区分string类型和它的包装类型。包装对象用new创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></div><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'str',生成了新的包装类型</span></div></pre></td></tr></table></figure><p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure><p>所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！</p><p>如果我们在使用Number、Boolean和String时，没有写new会发生什么情况？</p><p>此时，Number()、Boolean和String()被当做普通函数，把任何类型的数据转换为number、boolean和string类型（注意不是其包装类型）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">// 123，相当于parseInt()或parseFloat()</span></div><div class="line"><span class="keyword">typeof</span> n; <span class="comment">// 'number'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Boolean</span>(<span class="string">'true'</span>); <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> b; <span class="comment">// 'boolean'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">'false'</span>); <span class="comment">// true! 'false'字符串转换结果为true！因为它是非空字符串！</span></div><div class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">''</span>); <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="built_in">String</span>(<span class="number">123.45</span>); <span class="comment">// '123.45'</span></div><div class="line"><span class="keyword">typeof</span> s; <span class="comment">// 'string'</span></div></pre></td></tr></table></figure><p>是不是感觉头大了？这就是JavaScript特有的催眠魅力！</p><p>总结一下，有这么几条规则需要遵守：</p><ul><li><p>不要使用new Number()、new Boolean()、new String()创建包装对象；</p></li><li><p>用parseInt()或parseFloat()来转换任意类型到number；</p></li><li><p>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</p></li><li><p>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</p></li><li><p>typeof操作符可以判断出number、boolean、string、function和undefined；</p></li><li><p>判断Array要使用Array.isArray(arr)；</p></li><li><p>判断null请使用myVar === null；</p></li><li><p>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</p></li><li><p>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</p></li></ul><p>最后有细心的同学指出，任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。</p><p>更细心的同学指出，number对象调用toString()报SyntaxError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">123.</span>toString(); <span class="comment">// SyntaxError</span></div></pre></td></tr></table></figure><p>遇到这种情况，要特殊处理一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">123.</span>.toString(); <span class="comment">// '123', 注意是两个点！</span></div><div class="line">(<span class="number">123</span>).toString(); <span class="comment">// '123'</span></div></pre></td></tr></table></figure><h4 id="12-Date"><a href="#12-Date" class="headerlink" title="12.Date()"></a>12.Date()</h4><p>在JavaScript中，Date对象用来表示日期和时间。</p><p>要获取系统当前时间，用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></div><div class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></div><div class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></div><div class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></div><div class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></div><div class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></div><div class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></div><div class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure><p>注意，当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。</p><p>如果要创建一个指定日期和时间的Date对象，可以用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">123</span>);</div><div class="line">d; <span class="comment">// Fri Jun 19 2015 20:15:30 GMT+0800 (CST)</span></div></pre></td></tr></table></figure><p>你可能观察到了一个非常非常坑爹的地方，就是JavaScript的月份范围用整数表示是0~11，0表示一月，1表示二月……，所以要表示6月，我们传入的是5！这绝对是JavaScript的设计者当时脑抽了一下，但是现在要修复已经不可能了。</p>
				<!-- 多说评论框 start -->
				<div class="article-comment">
					<div class="ds-thread" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="50" data-thread-key="post-jsBug" data-title="Javascript 设计缺陷" data-url="/"></div>
				</div>
				<!-- 多说评论框 end -->
			
		</div>
		<footer class="article-footer">
			<a data-url="https://utopia1991.github.io/2017/06/08/jsBug/" data-id="cj3o2kjuq001k5jtdsoai8qcf" class="article-share-link">分享</a>
			
			
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript/">Javascript</a></li></ul>

		</footer>
	</div>
	
		
<nav id="article-nav">
  
    <a href="/2017/06/08/interview2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          20个JS变态面试题解析
        
      </div>
    </a>
  
  
    <a href="/2017/06/08/interview3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">JavaScript 单线程机制面试题</div>
    </a>
  
</nav>

	
</article>



				</section>
			</div>
			<footer id="footer">
	
	<div class="outer">
		<div id="footer-info">
			Copyright &copy; Bevis Shen 2017<br>
			Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
		</div>
	</div>
</footer>

		</div>
		<nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">博文</a>
  
</nav>
		

<script src="https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

	</div>
</body>
<script>
	function backTop(){
		document.documentElement.scrollTop = document.body.scrollTop = 0;
	}

	var c = document.getElementsByTagName('canvas')[0],
		x = c.getContext('2d'),
		pr = window.devicePixelRatio || 1,
		w = window.innerWidth,
		h = window.innerHeight,
		f = 90,
		q,
		m = Math,
		r = 0,
		u = m.PI * 2,
		v = m.cos,
		z = m.random
	c.width = w * pr
	c.height = h * pr
	x.scale(pr, pr)
	x.globalAlpha = 0.6

	function i() {
		x.clearRect(0, 0, w, h)
		q = [{
			x: 0,
			y: h * .7 + f
		}, {
			x: 0,
			y: h * .7 - f
		}]
		while (q[1].x < w + f) d(q[0], q[1])
	}

	function d(i, j) {
		x.beginPath()
		x.moveTo(i.x, i.y)
		x.lineTo(j.x, j.y)
		var k = j.x + (z() * 2 - 0.25) * f,
			n = y(j.y)
		x.lineTo(k, n)
		x.closePath()
		r -= u / -50
		x.fillStyle = '#' + (v(r) * 127 + 128 << 16 | v(r + u / 3) * 127 + 128 << 8 | v(r + u / 3 * 2) * 127 + 128).toString(16)
		x.fill()
		q[0] = q[1]
		q[1] = {
			x: k,
			y: n
		}
	}

	function y(p) {
		var t = p + (z() * 2 - 1.1) * f
		return (t > h || t < 0) ? y(p) : t
	}
	document.onclick = i
	document.ontouchstart = i
	i()
</script>
</html>
